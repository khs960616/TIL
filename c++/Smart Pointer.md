## 스마트 포인터(Smart Poiner)

```
std::unique_ptr   (연관 함수, get(), release(), mov())
→ raw pointer를 단독으로 소유한다. 따라서, 복사나 대입 연산이 불가능하다.
→ unique_ptr 변수가 해당 함수의 Scope를 벗어나면, 원시포인터가 자동으로 delete 된다.
사용하는 케이스
1. 클래스의 멤버로 동적할당한 메모리를 가르키는 raw 포인터가 존재하는 경우
2. STL컨테이너의 요소로 동적할당한 데이터를 저장할 때 
 → 컨테이너 clear();시 내부에 존재하는 모든 객체에 대한 소멸자가 호출된다.

(단 c++14에서 제공되는 make_unique 함수로 생성된 케이스가 아니라면, 포인터를 생성자에 대입하는 형태로 사용하는 경우, raw pointer를 중복해서 여러 unique_ptr에 넣는것을 주의해야한다. 
```
```
std::shared_ptr
→ 객체의 소유권을 다른 포인터들과 공유할 수 있는 포인터이다.
→ reference count를 사용하여, 객체의 해제 여부를 판단한다. (0이 되는순간 delete)
→ default로는 delete함수만 사용하므로, delete[]를 호출하지 않는다. 따라서 Deleter 구조체 또는 람다를 정의하여, 생성자의 두 번째 인자로 건네주는 경우, 원하는 소멸자를 호출하도록할 수 있다. 
→ 순환참조가 발생할 수 있으며, 멀티스레드에서 사용하는 경우 쓰기 연산에 주의해야한다.
```
```
std::weak_ptr
→ reference count를 증가시키지 않는 약한 참조가 필요한 경우에 (특정 클래스가 서로를 참조하는 구조)
사용한다. (shared_ptr만 생성자에 넣어, 약한 참조 생성을 할 수 있다)
→ weak_ptr로 포인터에 직접 접근은 불가능하며, 참조가 필요한 경우 lock()함수를 통해 일시적으로 shared_ptr를 생성한 다음, 해당 포인터로 접근하여 사용한다.
```
