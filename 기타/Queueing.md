Direct hadoffs
---
작업들을 바로 스레드들에게 넘겨준다.

여기서 하나의 작업을 큐에 넣는 시도는 즉시 그것을 실행할 수 있는 스레드가 없다면 실패할 것이다. 

그래서 새로운 스레드가 생성된다. 이 정책은 내부적인 의존을 가지고 있을지 모를 요청들의 집합들을 다룰 때 고정을 회피한다. 보

통 제한없은 maximumPoolSize가 필요하며 새로 등록된 작업의 거절을 회피한다. 스레들이 처리할 수 있는 것보다 더 빨리 명령들이 도작하면 제한없은 스레드의 성장 가능성이 존재한다.


Unbounded queues
---
미리 정의된 수용능력을 사용하지 않는 LinkedBlockingQueue와 같은 제한이 없는 큐는 모든 corePoolSize 스레들이 모두 바쁠 때는 새로운 작업이 큐 내부에서 대기하도록 한다

따라서 corePoolSize 스레드 이상의 것들은 만들어지지 않는다. 따라서 maximumPoolSize는 아무런 영향도 없다. 이것은 각각의 작업이 다른 작업들에 대해 완전히 독립적일 때 적당하다. 

처리능력을 초과하는 명령들이 지속적으로 도착하면  작업 큐의 성장 가능성이 있다.

Bounded queues
---

ArrayBlockingQueue 같은 제한된 큐는 제한된 maximumPoolSize가 사용되었을 때 자원의 고갈을 방지한다. 

하지만 제어와 조율이 훨씬 어려울 수 있다. 큐 사이즈와 maximumPoolSize는 서로 trade off된다. 

큰 사이즈의 큐와 작은 사이즈의 풀은 CPU 사용율, OS 자원, context 교환 overhead를  최소화한다. 하지만 의도적으로 적은 처리량을 이끌어 낼 수 있다. 

만약 작업들이 빈번하게 블록된다면 시스템은 허용한 개수보다 더 많은 스레드들에 대해 시간을 계획할 것이다.

일반적으로 작은 사이즈의 큐는 CPU 사용율을 높이는 큰 풀 사이즈를 요구한다. 하지만 처리량을 감소시키는 받아들일 수 없는 스케줄링 오버헤드와 만나게 된다.





https://blog.naver.com/PostView.naver?blogId=jssy23&logNo=222107628663
