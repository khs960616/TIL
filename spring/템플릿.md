# 분리와 재사용을 위한 디자인 패턴 적용

애플리케이션의 코드 중 많은 곳에서 중복되는 코드들의 경우

해당 코드가 각기 다른 컴포넌트에서 사용될 때 변하지 않는 부분과, 변하는 부분으로 나누어 구분한 후, 변하지 않는 부분을 재활용할 수 있는 방법을 생각해볼 수 있다.

1. 중복되는 코드부분을 메서드로 추출하는 방법

2. 템플릿 메소드 패턴의 적용 (상속을 통해 기능을 확장해서 사용하는 방법) : 변하지 않는 부분은 슈퍼클래스로, 변하는 부분은 추상 메소드로 정의하여 서브클래스에서 오버라이드해서 사용하는 방법
   - 각기 다른 클래스에서 템플릿 메소드 패턴을 활용해 재사용성을 늘리는 경우, 매번 클래스를 상속받는 자식 클래스를 만들어야한다. 
   - 확장 구조가 클래스를 설계하는 시점에 고정되어 버린다.

3. 전략 패턴 적용
  - 변하지 않는 부분과, 변하는 부분의 코드를 각기 다른 오브젝트로 관심사를 분리한후, 두 클래스가 인터페이스를 통해서만 의존하도록 만든다.
  - Context가 어떠한 전략을 사용받을지 외부로 부터 주입받아서 해당 일을 하도록 처리한다. 

---
# 전략과 클라이언트의 동거

전략 패턴을 사용하여 재사용을 위한 디자인을 하는 경우, 메소드의 중복되지 않는 부분별로 인터페이스를 정의하고, 각 메소드별 구현체를 새롭게 정의해야하므로 기존 코드보다 클래스파일의 개수가 많아지며
각 구현체에 전달해야 매개변수가 존재하는 경우 구현체에서 해당 변수를 저장하기 위해 또 별도의 인스턴스 변수를 만들어야하는 문제가 있다.

로컬 클래스 
   - 실제로 중복되는 코드를 재사용하기 위해 전략패턴을 사용한 경우, 각 구현체는 해당 클래스에서만 사용되고, 다른 클래스에서 사용할 일이 없다면 inner class로 정의하면, 비교적 프로젝트 구조를 깔끔하게 유지 할 수 있다. 또한 메서드 레벨에서 local class를 정의하는 경우 구현체에 생성자 또는 수정자를 통해 parameter를 넘겨 받지 않고, 외부 메서드의 변수를 그대로 활용할 수 있는 장점이 존재한다.

---
# 스프링 빈으로 DI

클래스가 특정 서비스를 제공하는 오브젝트로써 프로젝트 내부에서 구현 방법이 바뀔 가능성이 없는 경우에도 반드시 인터페이스를 만들고, 인터페이스를 구현하는 구현체를 만들고
인터페이스를 통하여 DI를 해야할까?
되며, 
> 토비의 스프링 3.0 왈 : DI 라는 개념을 충실히 따지면, 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않게 하고, 런타임시에 의존할 오브젝트와의 관계를
> 다이나믹하게 주입하는 것이 맞다. 따라서 엄밀히 이야기하면 인터페이스를 사용하지 않고 클래스 레벨로 주입하는 것은 온전한 DI라고 볼 수는 없다.
> 그러나 스프링의 DI를 넓게 보면, 객체의 생성과 관계설정에 대한 제어권한을 오브젝트에서 제거, 외부로 위임하는 IOC개념을 포괄하므로, 클래스에 의존 클래스를 주입하는 것도 DI의 기본을 따르고 있다고 볼수 있다.
> 인터페이스를 이용하지 않느냐, 이용하느냐의 차이는 각각의 클래스가 강한 응집도를 가지느냐, 안가지느냐에 따라 결정된다. (인터페이스를 만들기 귀찮아서 인터페이스를 사용하지 않는 것은 잘못된 생각이다, 이러한 방식은 설계시 항상 마지막에 고민해볼 문제이며 그냥 인터페이스로 만들어서 주입해도 문제되는 부분이없다.) 

인터페이스를 통해 구현체를 DI하는 경우가 아니더라도 (런타임 시에 다이나믹하게 구현체가 별할 수 없는 경우임에도) DI를 하는 이유?
1. 해당 객체가 Application Context에서 관리하는 싱글톤 빈이 되기 때문이다. (state가 존재하지 않는 서비스 오브젝트는 매번 새롭게 생성할 필요가 없다.)
2. 해당 객체가 자체적으로 DI를 통해 다른 오브젝트를 주입받아야 되는 경우(DI를 받는 오브젝트, 주입되는 오브젝트 둘다 스프링 빈으로 등록되야 DI에 참여될수 있다.)

-----
위 방법이 싫다면, 각 구현체의 생성을 사용하는 클래스에서 직접 선언해서 사용하는 방법도 고려해볼만하다. 

(단 이 경우에는 스프링에 의해 의존 관계를 주입받지 못하므로, 주입받는 객체마다 새로운 인스턴스가 주입되므로 고민해봐야한다.)


(개인적으로는 전역적으로 많이 사용되는 빈의 경우에는 구현이 변화할 이유가 없더라도, 인터페이스로 DI를 할 수 있고, 어쩌피 싱글톤으로 사용하는게 유리하다면 인터페이스를 만들어서 주입하는게 나은 것 같다. 개발 초기에는 조금 귀찮더라도 만들고 나면 실제 구현체도 변화시킬 수 있는 것이 마음에 안정감이 올 거 같음..) 

---
# 템플릿과 콜백
템플릿(전략 패턴의 컨텍스트에 해당), 콜백 (익명 내부 클래스로 만들어지는 오브젝트) 

**템플릿/콜백 패턴** : 일정한 패턴을 갖는 작업 흐름이 존재하고, 그중 일부분만 자주 바꿔서 사용해야하는 경우 위애서 서술한 방식 같이 전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식
   - 전략 패턴은 여러개의 메소드를 가진 인터페이스를 사용하는 것과 달리, 템플릿/콜백 패턴은 단일 메소드 인터페이스를 사용하는 경우가 빈번하다. 일반적으로 해당 패턴을 활용할 때 내부 익명 클래스로 콜백을 만든다.
   - 일반적으로 콜백 인터페이스의 메소드는 템플릿의 작업 흐름중에 만들어지는 컨텍스트 정보를 받기 위한 파라미터를 가진다.

일반적인 템플릿/ 콜백 패턴의 flow 
(Client) -> 콜백 생성  -> 템플릿에게 CallBack 전달 및 호출 -> (템플릿) workFlow 시작 -> 참조정보 생성 ->
callBack호출 및 참조정보 전달 -> (callback) -> 변수 참조 -> 작업 수행 -> 작업결과 전달 -> (템플릿) workflow 진행 및 마무리 -> template 작업결과 client에게 전달 


# 제네릭을 이용한 콜백 인터페이스 
콜백 인터페이스 설계 시 제네릭을 활용하면, 좀 더 확장성 있고 강력한 템플릿/콜백 구조를 만들어낼 수 있다. 

--------------------------------------------------------------------------------------
# 중첩 클래스(nested class) : 다른 클래스 내부에 정의되는 클래스 
- static class : 외부 인스턴스의 생성없이 독립적인 오브젝트로 만들어질 수 있는 클래스 
- inner class : 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 클래스 (scope에 따라 세분화된다) 
   1) Member inner class : 멤버 필드처럼 오브젝트 레벨에서 정의되는 클래스
   2) local class : 블록 레벨에 정의되는 로컬 클래스 (표현식, statements, 블록 모두에서 선언이 가능하다. enclosing class 맴버 및 final로 선언된 외부 변수 접근 가능 )
   - 자신이 정의된 메소드의 로컬변수에 직접 접근할 수 있으므로, 생성자, 수정자를 통해 해당 변수를 넘겨받을 필요가 없다는 장점선언 이 존재(단, 이때 사용하는 외부 변수는 final로 선언되어있어야한다.)
   3) anonymous inner class : 이름을 갖지 않는 익명 내부 클래스 (선언 위치에 따라 scope를 달리 가진다)
   - 클래스 생성과 오브젝트 생성이 동시에 된다. (p230)

(static class가 아닌 inner class는 숨은 외부 참조가 존재한다. 
참조값을 담아야 하기 때문에, 인스턴스 생성시 시간적, 공간적으로 성능이 static class보다 떨어지며, 외부 인스턴스에 대한 참조가 존재하기 때문에, 가비지 컬렉션이 인스턴스 수거를 하지 못하여 메모리 누수가 생길 수 있다는 단점 존재.)

https://docs.oracle.com/javase/tutorial/java/javaOO/whentouse.html
