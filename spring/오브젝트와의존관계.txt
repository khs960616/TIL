분리와 확장이 고려된 객체 지향적인 개발방식은 변화에 효과적으로 대처할수 있도록 해준다. 

분리 : 일반적으로 변경사항이나 발전사항은 한 번에 한 가지 관심사항에 집중해서 일어난다. 

(관심사의 분리) 관심이 같은 것 끼리 모아주어야한다. 

템플릿 메소드 패턴
: 슈퍼클래스의 기본적인 로직의 흐름을 만들고, 기능중 일부를 추상 메서드로 만들거나, 
오버라이딩이 가능한 protected 메소드등으로 만들어 하위 클래스에서 구현해서 사용하도록 만드는 방법
(변하지 않는 기능 -> 슈퍼클래스에 만듬, 자주 변하는 기능 -> 하위 클래스에서 구현하도록 만듬)


훅 메서드: 
슈퍼클래스에서 디폴트 기능을 정의해두거나, 비워두었다가 서브 클래스에서 선택적으로 오버라이즈 할 수 있도록 만들어둔 메서드 

팩토리 메서드 패턴 : 서브클래스에서 해당 클래스에서 사용되는 특정 오브젝트를 어떤 식으로 생성할 것인지 결정하게 만드는 패턴
(자바에서는 일반적으로 오브젝트를 만드는 메서드를 팩토리 메서드라고 부르기도 해는데 혼동해서는 안됨)


결국 위 세가지 디자인 패턴은 상속을 통해 슈퍼클래스의 기능을 확장해서 사용하겠다는 의미가 크다.  

상속을 이용한 관심사의 분리의 한계점?
1. 자바에서는 다중 상속이 되지 않기 때문에 만약 나중에 다른 관심사를 추가적으로 분리해야되는 경우 슈퍼클래스를 활용하기 어렵다.
2. 슈퍼클래스와 하위 클래스의 관계가 생각보다 밀접하다. 


OCP (Open-Close- principle) 개방 폐쇠 원칙
: 확장에는 열려있고 수정에는 닫혀있는 설계 원칙 


높은 응집도와 낮은 결합도
응집도가 높다는 의미는 변화가 일어날때 해당 모듈에서 변하는 부분이 크다는 것이다. 
낮은 결합도(중요) 책임과 관심사가 다른 오브젝트들 간에는 결합이 느슨하다. (관계를 유지하기 위한 최소한의 정보만 클라이언트 측에 둠으로써 결합도를 낮춰야한다.) 

Inversion of Control (IoC) 제어의 역전 : 프로그램의 제어 흐름 구조가 뒤바뀌는 것
(오브젝트가 자신이 사용할 오브젝트를 스스로 선택하거나 생성하지 않고, 제어 권한을 다른 대상에게 위임한다.)
-> 프레임워크, 컨테이너와 같이 애플리케이션 컴포넌트의 생성, 관계설정, 사용, 생명주기 관리등을 관장하는 존재가 필요하다.


Bean : 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트(애플리케이션 컴포넌트)
ApplicationContext (Bean Factory의 확장) : 빈의 생성과 관계설정과 같은 제어를 담당하는 IoC 오브젝트 

@Configuration : 빈 팩토리가 사용할 설정 정보를 나타낸다.
@Bean : 오브젝트 생성을 담당하는 IoC 메서드임을 나타낸다. 

오브젝트 팩토리를 직접 사용하는 것보다 Application Context를 사용함으로써 얻을 수 있는 이점
1. 클라이언트가 구체적인 팩토리 클래스를 알 필요가 없다.
2. 종합 IoC 서비스를 제공해준다.
(단지 오브젝트의 생성과 관계설정뿐만이 나닌, 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수 있으며, 이에 부가적으로 자동생성, 오브젝트에 대한 후처리, 인터셉팅 등 오브젝트를 효과적으로 이용할 수 있는 기능을 제공한다.)
3. Bean을 검색할 수 있는 다양한 방법을 제공한다. 

싱글톤 레지스트리, 오브젝트 스코프
일반적인 자바 오브젝트 팩토리로 만드는 경우 싱글톤 인스턴스를 반환하도록 구현하지 않는 이상 매번 다른 인스턴스를 반환한다.

스프링이 주로 적용되는 대상은 자바 엔터프라이즈 기술을 사용하는 서버 환경이다. 이러한 환경에서 매번 클라이언트에 요청을 처리하는,
각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다면 서버에 부하가 걸리게 된다. 
스프링 이전부터 이러한 부하를 막기 위해, 엔터프라이즈 분야에서는 서비스 오브젝트 개념을 사용해왔다. (서블릿 클래스당 하나의 오브젝트만 만들어두고, 여러 스레드에서 해당 오브젝트를 공유해서 사용)

일반적인 싱글톤 패턴은 생성자를 private으로 만든 후, 클래스 내부에 static한 인스턴스를 하나 만들어서, 한번 오브젝트가 생성된 이후부터 동일한 인스턴스를 반환하도록한다.
이러한 싱글톤 패턴 구현 방식은 다음과 같은 문제점이 존재한다.
1. 생성자가 private이므로 상속이 불가능하다. (상속과 다형성을 활용하기 어려워진다.)
2. 싱글톤은 테스트하기 어렵다. 
3. 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보정하지 못한다. (클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질수 있다.

스프링에서 Application Context는 싱글톤 레지스트리의 역할을 한다. 이를 활용해 평범한 자바 클래스를 싱글톤으로 이용하도록 돕는다.
> 스프링 컨테이너에 의해 만들어진 Bean은 싱글톤으로 만들어지므로 stateless 해야한다. (그렇지 않은 경우, 여러 스레드가 공유해서 사용하므로 race condition등 문제가 생긴다.)
> 읽기 전용 값을 인스턴스 변수에 저장하고 공유하는 것은 문제가 되지 않는다. 

Bean Scope : 빈이 생성되고, 존재하고, 적용되는 범위

Singleton: 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 하나의 인스턴스가 유지된다.
-> 별다른 설정을 하지 않는 경우 Bean의 기본적인 Scope가 된다.
Prototype Scope : 각 빈을 요청할 때마다 매번 새로운 오브젝트를 반환한다.
-> 생성된 빈은 더 이상 스프링 컨테이너에 의해 관리되지 않으며, 해당 빈을 생성한 오브젝트 종속적이게 된다. (gc에 의해 제거된다.)
Request Scope : HTTP 요청이 생길때마다 생성되고, 해당 요청이 끝날 때 인스턴스도 같이 사라진다. (각 요청별로 독립적인 Bean이 생성되므로 상태를 가져도된다.)
-> 애플리케이션 코드로 생성된 정보를 프레임워크 레벨의 서비스나, 인터셉터등에 전달하는 것이 가능해진다. 
Session Scope : HTTP Session 마다 하나의 빈을 사용 

Dependency Injection(DI) 의존성 주입 

의존관계 결정 시에는 먼저 방향성을 부여해야한다. (어떠한 클래스가 어떤 클래스의 종속적인지)
A 클래스가 B클래스에 의존하는 경우, A클래스의 변화에 B클래스는 변화되지 않지만, 
B클래스가 변하는 경우 해당 클래스에 의존하고 있는 A클래스에도 영향이 생긴다.  (사용에 대한 의존관계)

특정 클래스가 인터페이스에 의존적이게 만들면, 인터페이스의 구현체와는 비교적 느슨한 관계를 가지게되며 변화에 덜 영향을 받는다. (결합도가 낮다)

의존오브젝트 : 런타임시에 의존관계를 맺는 대상(실제 사용대상이 되는 오브젝트) 
//ex) 스프링에서 특정 클래스에 인터페이스를 멤버변수로 가지게하고, 실제 구현체를 Bean으로 만들어서 주입하는 경우 
//코드나 설계에서는 의존오브젝트를 사용하는 객체에 어떤 구현체를 사용할 지 드러나지 않지만, 실제 런타임시에는 구현체가 주입됨 

DI 란?
1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. (단지 인터페이스에 의존하는 것 처럼 보인다.)
2. 런타임 시점의 의존관계는 컨테이너, 혹은 팩토리 같은 제 3의 존재가 결정한다. 
3. 의존관계는 사용할 오브젝트에 대한 래퍼러스를 외부에서 제공해줌으로써 만들어진다.

위 조건을 만족하며, 클라이언트에 메소드를 활용해 의존 오브젝트의 래퍼런스를 전달해주는 일련의 과정 

Dependency LookUp (의존 관계 탐색)
런타임 시 의존 관계를 맺을 오브젝트는 외부 컨테이너에게 맡기지만, 이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청한다.

의존관계 검색 시에는 검색을 하는 오브젝트는 굳이 스프링 빈일 필요가 없다.
단 의존관계 주입 시에는 의존 오브젝트와 클라이언트 모두 빈으로 등록되어있어야 한다.

DI 사용시 관심사의 분리를 통해 높은 응집도를 얻을 수 있다.
