### 데이터 베이스에서 인덱스란?

데이터 베이스 테이블에 대한 검색 구조를 향상 시켜주는 자료 구조이다.
테이블의 특정 Column에 대한 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 물리적 주소와 함께 저장한다.

---
인덱스의 장점
1. 테이블을 검색하는 속도와 성능이 향상된다.
2. 인덱스에 의해 데이터들이 정렬된 형태를 가진다. (정렬이 되면 데이터를 풀 스캔 할 필요 없이 조건에 맞는 데이터를 빠르게 찾을 수 있다.)

인덱스 사용시의 단점 
1. 인덱스를 관리하기 위한 추가 작업이 필요하다.
  - 특정 레코드를 추가하는 경우, 해당 레코드가 속하는 테이블에 설정된 인덱스만큼, 해당 새로운 데이터에 대한 인덱스가 추가되어야한다.
  - 특정 레코드를 삭제하는 경우, 기존에 존재했던 해당 데이터의 인덱스를 사용하지 않은 처리를 해야한다.
  - 특정 레코드를 업데이트 하는 경우, 기존의 인덱스를 사용하지 않은 처리를 하고 갱신된 데이터에 대한 인덱스를 추가한다.
  
2. 인덱스 파일을 위한 추가 저장 공간이 필요하다.
3. 잘못 사용하는 경우 오히려 검색 성능 저하가 오게 된다. 
  
---

인덱스를 효율적으로 활용하기 위해선 데이터의 range가 넓고 조회가 빈번하거나, 정렬된 상태가 유용한 경우 효율적이다.

1. 규모가 큰 테이블
2. 삽입, 수정, 삭제 작업이 자주 발생하지 않는 컬럼
3. Where, order by, join이 자주 발생하는 컬럼
4. 데이터의 중복도가 낮은 컬럼

---
Clustered Index  vs UnClustered Index 

실제 인덱스의 정렬 구조에 맞춰 디스크에도 정렬된 순서대로 데이터가 존재하는 경우 Clustered Index라 한다.
디스크 I/O는 일반적으로 페이지 단위로 하기 때문에, Clustered Index를 사용하는 경우 Disk I/O를 줄일 수 있어 효과적이다.
하나의 테이블에 대해 Clustered Index는 하나만 존재할 수 있다.

일반적으로 MySQL은 다음의 과정으로 Clustered Index를 지정한다.
1. 테이블에 Auto Increments 값으로 PK가 존재한다면 해당 컬럼을 기준으로 한다.
2. 1번의 조건에 걸리지 않는 경우 Unique 컬럼을  Clustered Index로 지정한다.
3. 2번의 조건에도 부합하지 않는 다면 내부적으로 hidden index ID를 만들어 사용한다.


데이터가 적은 테이블에서는 Index보다 풀스캔이 빠르다.
인덱스는 기본적으로 인덱스 파일을 먼저 뒤진 후 디스크 접근을 하기 때문이다.
  
인덱스 컬럼을 기준으로 조회를 날렸는데 데이터를 풀스캐닝 하는 경우?

1. 인덱스 값에 데이터의 가공을 하려는 경우 
  ex)  where idx_key * 0.1 > 99999
       where idx_key > 99999 * 10
  
  전자의 경우 인덱스가 동작하지 않는다. (해당 컬럼의 값에 실제로 곱해보기 전까지는 결과를 미리 예측할 수 없다.)
  후자의 경우 인덱스가 동작한다. (특정 값을 기준으로 range 쿼리하면 되기 때문)
  
2. where idx_key != 100 등 부정형으로 where절에 사용하는 경우 해당 데이터를 제외한 모든 데이터를 스캔해야하므로 풀스캔으로 동작한다.

3. like 앞에 %를 붙히는 경우 

4. 멀티 컬럼에서 두번째 컬럼을 조건으로 사용하는 경우 (인덱스 파일이 첫 번째 컬럼, 두번째 컬럼 순으로 정렬되어 있으므로)
  
