![아키텍처](./images/mysql-architecture.png)

### MySQL 엔진
요청된 SQL문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다.

크게 커넥션 핸들러, SQL 인터페이스, SQL 파서, SQL 옵티마이저, 캐시 버퍼로 구성된다. 

---  
### MySQL 스레딩 구조
MySQL 서버는 프로세스 기반이 아닌 스레드를 기반으로 작동하며 크게 Foreground Thread, BackGround Thread로 구분된다. 

```
왜 프로세스 대신 스레드를 기반을 동작하는지 책에 안나와있어서.. 자료를 찾아봤는데 아직 못찾음.. 찾으면 ref 추가하자..

개인적으로 생각해봤을 때는 다음 두 가지 이유로 스레드를 기반으로 동작하도록 만들어졌을 것 같다.
1. 보다 많은 처리량을 위해서는 많은 양의 쿼리를 interleaving 해가며 처리해야함 -> 컨텍스트 스위칭 하는 비용이 적지 않을 것이라 생각됨)
2. 각 사용자의 요청별로 mysql 서버를  프로세스 형태로 계속 띄우면 너무나 많은 메모리를 요구할 것 같음
```

```
select thread_id, name, type, processlist_user, processlist_host from performance_schema.threads;
```
MySQL 서버에서 실행 중인 스레드 목록은 다음의 쿼리를 통해 확인할 수 있다. 


#### Foreground Thread
Foreground Thread(클라이언트 스레드)는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, **각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다.**

사용자가 작업을 마치면 커넥션을 담당하는 스레드는 다시 스레드 캐시로 되돌아가며, 스레드 캐시에 이미 일정 갯수 이상의 스레드가 있다면 스레드를 종료시킨다. 

(thread_cache_size 시스템 변수로 캐싱되는 스레드 개수를 조절할 수 있다.)

이러한 클라이언트 스레드는 데이터를 데이터 버퍼나 캐시로부터 가져오며, 만약 버퍼나 캐시에서 원하는 데이터가 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어

작업을 처리한다. 

스토리지 엔진으로 MyISAM을 사용하는 테이블의 경우, 디스크 write 작업까지 포그라운드 스레드가 처리하지만, InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고,

나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.

#### Background Thread
InnoDB는 다음과 같은 스레드를 백그라운드로 처리한다.
1. 인서트 버퍼 병합 스레드
2. **로그를 디스크로 기록하는 스레드**
3. **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드**
4. 데이터를 버퍼로 읽어오는 스레드
5. Lock 또는 dead Lock을 모니터링 하는 스레드 

일반적인 사용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 있다고 한다.

InnoDB 또한 이러한 방식을 선택한다.

MyISAM은 사용자 쓰레드가 쓰기작업까지 함께 처리하도록 설계되어, 쓰기 버퍼링 기능을 사용할 수 없다고 한다. 

---

### 스토리지 엔진 
실제 데이터를 디스크 스토리지에 저장하거나, 디스크 스토리지로부터 Read한다.

MySQL에서 스토리지 엔진은 여러 개를 동시에 사용할 수 있으며, 

각 스토리지 엔진은 성능향상을 위해 키 캐시(MyISAM), InnoDB 버퍼풀 등의 기능을 내장하고 있다.
